 .wrap_target
    in pins, 2           ; read the two pins to get value
    mov y, isr           ; put it in y to make comparison later
checking:
    set isr, 0           ; clear values ready for next reading
    in pins, 2           ; read latest value
    mov x, isr           ; mov to x to make comparison
    jmp x!=y on_change   ; compare
    jmp checking         ; check again if same
on_change:
    mov x, osr           ; move contents of osr to x - this is the count
    mov osr, y           ; move previous value in osr in order get the single bit
    out 1, y             ; get the individual bit
    jmp y-- was_1        ; if its now zero it was 1
    jmp pin dec          ; it was zero so if other pins 1 then dec
    jmp inc              ; if you get here they were the same, so increment
was_1:
    jmp pin inc          ; same so inc, otherwise fall through and dec
dec:
    jmp x-- send         
    send
inc:
    mov x, !x
    jmp x-- fake          ; just need to dec and fall through
fake:
    mov x, !x             ; inc complete, fall through to send
send:
    mov isr, x            ; move count to isr
    push                  ; send it out (also clears isr ready for next read)
    mov osr, x            ; move count to osr so can use x and y for comparison again
.wrap

% c-sdk {
static inline void encoders_program_init(PIO pio, uint sm, uint offset, uint pin) {
    pio_sm_set_consecutive_pindirs(pio, sm, pin, 1, false);
    pio_gpio_init(pio, pin);
    gpio_pull_up(pin);

    pio_sm_config c = encoders_program_get_default_config(offset);
    sm_config_set_in_pins(&c, pin); // for WAIT, IN
    sm_config_set_jmp_pin(&c, pin); // for JMP
    // Shift to right, autopull disabled
    sm_config_set_in_shift(&c, true, false, 2);

    pio_sm_init(pio, sm, offset, &c);
    pio_sm_set_enabled(pio, sm, true);
}
